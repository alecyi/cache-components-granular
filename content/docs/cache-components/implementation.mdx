---
title: Implementaci√≥n
description: C√≥digo completo paso a paso
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { Step, Steps } from 'fumadocs-ui/components/steps';

# Implementaci√≥n Completa

<Steps>

### Habilitar Cache Components

Actualiza `next.config.ts`:

```ts title="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  cacheComponents: true, // ‚Üê Habilita Cache Components
}

export default nextConfig
```

<Callout type="info">
Este flag habilita **Partial Prerendering (PPR)** autom√°ticamente.
</Callout>

### Crear queries separadas

Cada campo necesita su propia query:

```ts title="lib/db.ts"
export const db = {
  // Query SOLO para texto
  async getProductText(productId: string) {
    console.log(`[DB Query] üìù getProductText - Product ${productId}`)
    
    const { name, description } = await db.query(
      'SELECT name, description FROM products WHERE id = ?',
      [productId]
    )
    return { name, description }
  },

  // Query SOLO para precio
  async getProductPrice(productId: string) {
    console.log(`[DB Query] üí∞ getProductPrice - Product ${productId}`)
    
    const { price } = await db.query(
      'SELECT price FROM products WHERE id = ?',
      [productId]
    )
    return { price }
  },

  // Query SOLO para stock
  async getProductStock(productId: string) {
    console.log(`[DB Query] üì¶ getProductStock - Product ${productId}`)
    
    const { stock } = await db.query(
      'SELECT stock FROM products WHERE id = ?',
      [productId]
    )
    return { stock, lastChecked: new Date().toISOString() }
  },
}
```

<Callout type="warning">
**¬øPor qu√© m√∫ltiples queries?** Aunque parece ineficiente, las queries cacheadas se ejecutan en **build time**, no en cada request.
</Callout>

### Componente de texto (cacheado)

```tsx title="app/product/[id]/page.tsx"
async function ProductText({ productId }: { productId: string }) {
  'use cache'
  cacheTag(`product-text-${productId}`)
  cacheLife('weeks') // Cache largo: rara vez cambia
  
  const { name, description } = await db.getProductText(productId)
  
  return (
    <Card className="border-green-200">
      <CardHeader>
        <div className="flex items-start justify-between">
          <CardTitle>{name}</CardTitle>
          <Badge className="bg-green-100 text-green-800">
            üì¶ Cacheado 1 semana
          </Badge>
        </div>
        <CardDescription>{description}</CardDescription>
      </CardHeader>
    </Card>
  )
}
```

**Puntos clave:**
- `'use cache'` marca el componente como cacheable
- `cacheTag` permite revalidaci√≥n selectiva
- `cacheLife('weeks')` define duraci√≥n del cache
- Query espec√≠fica solo para este campo

### Componente de precio (cacheado)

```tsx title="app/product/[id]/page.tsx"
async function ProductPrice({ productId }: { productId: string }) {
  'use cache'
  cacheTag(`product-price-${productId}`)
  cacheLife('hours') // Cache medio: cambia ocasionalmente
  
  const { price } = await db.getProductPrice(productId)
  
  return (
    <Card className="border-blue-200">
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardDescription>Precio</CardDescription>
            <CardTitle className="text-4xl">${price.toFixed(2)}</CardTitle>
          </div>
          <Badge className="bg-blue-100 text-blue-800">
            ‚è±Ô∏è Cacheado 1 hora
          </Badge>
        </div>
      </CardHeader>
    </Card>
  )
}
```

### Componente de stock (sin cache)

```tsx title="app/product/[id]/page.tsx"
async function ProductStock({ productId }: { productId: string }) {
  // Sin 'use cache' - siempre fresh
  
  const { stock, lastChecked } = await db.getProductStock(productId)
  
  return (
    <Card className="border-amber-200">
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardDescription>Stock disponible</CardDescription>
            <CardTitle className={stock < 10 ? 'text-red-600' : ''}>
              {stock} unidades
            </CardTitle>
            <p className="text-xs text-muted-foreground">
              Verificado: {new Date(lastChecked).toLocaleTimeString()}
            </p>
          </div>
          <Badge className="bg-amber-100 text-amber-800">
            üîÑ Sin cache (streaming)
          </Badge>
        </div>
      </CardHeader>
    </Card>
  )
}
```

<Callout type="success">
**Sin `use cache`** = el componente se ejecuta en cada request y hace streaming.
</Callout>

### P√°gina principal con Suspense

```tsx title="app/product/[id]/page.tsx"
import { Suspense } from 'react'

// Componente principal - SYNC, solo estructura
export default function ProductPage({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  return (
    <div className="container mx-auto px-4 py-8 max-w-4xl">
      <Link href="/">‚Üê Volver</Link>
      
      {/* Todo el contenido din√°mico en Suspense */}
      <Suspense fallback={<ProductPageSkeleton />}>
        <ProductContent params={params} />
      </Suspense>
    </div>
  )
}

// Contenido - ASYNC, accede a params
async function ProductContent({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  
  return (
    <div className="space-y-6">
      {/* Texto y precio: cacheados, van al static shell */}
      <ProductText productId={id} />
      <ProductPrice productId={id} />
      
      {/* Stock: sin cache, requiere Suspense adicional */}
      <Suspense fallback={<StockSkeleton />}>
        <ProductStock productId={id} />
      </Suspense>
    </div>
  )
}
```

<Callout type="error">
**Cr√≠tico:** `params` es runtime data y debe accederse dentro de Suspense.
</Callout>

### Server Actions para revalidaci√≥n

```ts title="app/actions.ts"
'use server'

import { revalidateTag } from 'next/cache'

export async function revalidateProductPrice(productId: string) {
  console.log(`[Server Action] Revalidating price for ${productId}`)
  revalidateTag(`product-price-${productId}`, 'max')
  return { success: true, message: 'Precio revalidado' }
}

export async function revalidateProductText(productId: string) {
  console.log(`[Server Action] Revalidating text for ${productId}`)
  revalidateTag(`product-text-${productId}`, 'max')
  return { success: true, message: 'Texto revalidado' }
}
```

</Steps>

## Timeline de ejecuci√≥n

<Tabs items={['Build time', 'Request time', 'Despu√©s de revalidaci√≥n']}>
  <Tab value="Build time">
    ```
    npm run build
    
    ‚úÖ ProductText ejecuta query ‚Üí resultado en static shell
    ‚úÖ ProductPrice ejecuta query ‚Üí resultado en static shell
    ‚ùå ProductStock NO se ejecuta (requiere request)
    
    Output: 
    - HTML con texto y precio ya renderizados
    - Placeholder para stock (Suspense fallback)
    ```
  </Tab>
  
  <Tab value="Request time">
    ```
    Usuario visita /product/1
    
    ‚ö° Browser recibe HTML inmediatamente
       - Texto: "Laptop Dell XPS 15" (del static shell)
       - Precio: "$1,299.99" (del static shell)
       - Stock: <StockSkeleton /> (placeholder)
    
    üîÑ Server ejecuta ProductStock
       - Query a DB para stock actual
    
    ‚ö° Stock hace streaming al browser
       - Reemplaza <StockSkeleton />
       - Usuario ve: "15 unidades"
    ```
  </Tab>
  
  <Tab value="Despu√©s de revalidaci√≥n">
    ```
    Usuario hace click en "Revalidar Precio"
    
    üîÑ revalidateProductPrice() ejecuta
       - Marca 'product-price-1' como stale
    
    üìù Pr√≥xima visita a /product/1:
       - Texto: Sigue del cache (no revalidado)
       - Precio: Se regenera en background
       - Stock: Se ejecuta fresh (sin cache)
    ```
  </Tab>
</Tabs>

## Verificaci√≥n

### En desarrollo

```bash
npm run dev
```

Abre http://localhost:3000 y verifica en consola del servidor:

```
[DB Query] üìù getProductText - Product 1
[DB Query] üí∞ getProductPrice - Product 1
[DB Query] üì¶ getProductStock - Product 1
```

### En producci√≥n

```bash
npm run build
npm start
```

Verifica en el output del build:

```
Route (app)                    Size     First Load JS
‚îå ‚óã /                          1.2 kB         85.3 kB
‚îî ∆í /product/[id]              2.5 kB         95.1 kB

‚óã  Static    - prerendered
∆í  Dynamic   - server-rendered on demand
```

<Callout type="success">
Si ves `∆í Dynamic` para `/product/[id]`, est√° funcionando correctamente.
</Callout>

## Debugging

### Ver qu√© se cachea

En el browser, haz View Source (Ctrl+U) y busca:

```html
<!-- Deber√≠as ver el HTML del texto y precio -->
<h1>Laptop Dell XPS 15</h1>
<p>Potente laptop con procesador...</p>
<div>$1,299.99</div>

<!-- El stock NO deber√≠a estar, solo el skeleton -->
```

### Logs √∫tiles

Agrega logs en cada componente:

```tsx
async function ProductPrice({ productId }) {
  'use cache'
  console.log(`[${new Date().toISOString()}] Rendering ProductPrice`)
  // ...
}
```

En build, deber√≠as ver el log una sola vez.
En request time, NO deber√≠as verlo (usa cache).
