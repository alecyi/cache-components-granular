---
title: Cache Components
description: Cacheo granular por campo en Next.js 16
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Card, Cards } from 'fumadocs-ui/components/card';
import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

# Cache Components - Cacheo Granular

<Callout type="info">
Demo interactivo de c√≥mo cachear **campos individuales** de un registro con diferentes estrategias en Next.js 16.
</Callout>

## El Problema

Imagina que tienes un **producto** con 3 campos:

- **Texto** (nombre + descripci√≥n): Rara vez cambia
- **Precio**: Cambia ocasionalmente  
- **Stock**: Debe estar siempre actualizado

¬øC√≥mo cacheas cada campo de forma independiente?

## ‚ùå Lo que NO funciona

```tsx
// Intentar cachear selectivamente desde un solo objeto
async function ProductPage({ productId }) {
  // Una sola query trae todo
  const product = await db.query('SELECT * FROM products WHERE id = ?')
  
  // ¬øC√≥mo cacheo solo el precio?
  // ¬øC√≥mo NO cacheo el stock?
  return <div>{product.name} - ${product.price} - Stock: {product.stock}</div>
}
```

**No funciona porque:** Una vez que tienes el objeto completo, no puedes aplicar `use cache` selectivamente a campos individuales.

## ‚úÖ La Soluci√≥n

Cada campo es un **componente async separado** con su propia query y estrategia de cache.

```tsx
export default function ProductPage({ params }) {
  return (
    <Suspense fallback={<PageSkeleton />}>
      <ProductContent params={params} />
    </Suspense>
  )
}

async function ProductContent({ params }) {
  const { id } = await params
  
  return (
    <div>
      {/* CAMPO 1: Texto cacheado */}
      <ProductText productId={id} />
      
      {/* CAMPO 2: Precio cacheado */}
      <ProductPrice productId={id} />
      
      {/* CAMPO 3: Stock sin cache */}
      <Suspense fallback={<StockSkeleton />}>
        <ProductStock productId={id} />
      </Suspense>
    </div>
  )
}
```

<Callout type="warning">
**Importante:** El Suspense va en el **padre**, no dentro del componente async.
</Callout>

## Arquitectura

```
ProductPage (sync - est√°tico)
‚îÇ
‚îî‚îÄ <Suspense>
   ‚îî‚îÄ ProductContent (async - accede a params)
      ‚îú‚îÄ ProductText (async + 'use cache')
      ‚îú‚îÄ ProductPrice (async + 'use cache')
      ‚îî‚îÄ <Suspense>
         ‚îî‚îÄ ProductStock (async sin cache)
```

## Comparaci√≥n Visual

<Tabs items={['Build Time', 'Request Time']}>
  <Tab value="Build Time">
    En build time, Next.js prerrenderiza la p√°gina:
    
    - ‚úÖ `ProductText` ejecuta query ‚Üí incluido en static shell
    - ‚úÖ `ProductPrice` ejecuta query ‚Üí incluido en static shell
    - ‚ùå `ProductStock` NO se ejecuta (requiere request context)
    
    **Resultado:** HTML con texto y precio ya renderizados
  </Tab>
  
  <Tab value="Request Time">
    Cuando un usuario visita la p√°gina:
    
    1. ‚ö° Browser recibe HTML instant√°neamente (texto + precio)
    2. ‚ö° Browser muestra skeleton del stock
    3. üîÑ Server ejecuta query de stock
    4. ‚ö° Stock hace streaming y reemplaza skeleton
  </Tab>
</Tabs>

## Siguientes pasos

<Cards>
  <Card 
    title="Implementaci√≥n" 
    href="/docs/cache-components/implementation"
    description="C√≥digo completo paso a paso"
  />
  <Card 
    title="Conceptos clave" 
    href="/docs/cache-components/concepts"
    description="Suspense, queries y cache"
  />
  <Card 
    title="Revalidaci√≥n" 
    href="/docs/cache-components/revalidation"
    description="updateTag vs revalidateTag"
  />
</Cards>
